library(tidyverse)
library(MendelianRandomization)
library(R2jags)
library(BWMR)
#library(MRcML)
library(parallel)
library(pbapply)
library(MR.Corr2)
Rcpp::sourceCpp("/Users/fengsihao/Desktop/Dr.Chen/sihao/fastlm.cpp")
source("/Users/fengsihao/paper_105/mr_horse.R")
source("/Users/fengsihao/paper_105/BWMR_updated.R")

#data generation===================
data_generation <- function(
    ng,                      
    nx,                     
    ny,                     
    a_f = 0.1,              
    b_f = 0.3,              
    a_beta_gx = 0.1,       
    b_beta_gx = 0.2,        
    a_beta_gu = 0.05,      
    b_beta_gu = 0.15,       
    a_alpha_gy = 0.1,       
    b_alpha_gy = 0.2,       
    theta = 0.1,            
    gamma_ux = 1,           
    gamma_uy = 1,           
    prop_valid = 0.5,       
    prop_correlated_pleio = 0.25,   
    prop_uncorrelated_pleio = 0.25  
) {
  
  
  f <- runif(ng, a_f, b_f)
  gx <- replicate(nx, rbinom(n = ng, size = 2, prob = f))
  gy <- replicate(ny, rbinom(n = ng, size = 2, prob = f))
  gx <- t(apply(gx, 1, function(x) {
    scaled <- scale(x)[,1]
    return(scaled)
  }))
  gy <- t(apply(gy, 1, function(x) {
    scaled <- scale(x)[,1]
    return(scaled)
  }))
  
  gx[is.na(gx)] <- 0
  gy[is.na(gy)] <- 0
  
  # assign idx
  total_prop <- prop_valid + prop_correlated_pleio + prop_uncorrelated_pleio
  if(total_prop > 1) {
    stop("total prop should be less than 1！")
  }
  
  n_valid <- floor(prop_valid * ng)
  n_corr_pleio <- floor(prop_correlated_pleio * ng)
  n_uncorr_pleio <- floor(prop_uncorrelated_pleio * ng)
  
  snp_assignment <- sample(1:ng, ng, replace = FALSE)
  crnt_idx <- 1
  
  # valid
  if(n_valid > 0) {
    valid_ids <- snp_assignment[crnt_idx:(crnt_idx + n_valid - 1)]
    crnt_idx <- crnt_idx + n_valid
  } else {
    valid_ids <- c()
  }
  
  # chp
  if(n_corr_pleio > 0 && crnt_idx <= ng) {
    corr_pleio_ids <- snp_assignment[crnt_idx:min(crnt_idx + n_corr_pleio - 1, ng)]
    crnt_idx <- crnt_idx + n_corr_pleio
  } else {
    corr_pleio_ids <- c()
  }
  
  # uhp
  if(n_uncorr_pleio > 0 && crnt_idx <= ng) {
    uncorr_pleio_ids <- snp_assignment[crnt_idx:min(crnt_idx + n_uncorr_pleio - 1, ng)]
    crnt_idx <- crnt_idx + n_uncorr_pleio
  } else {
    uncorr_pleio_ids <- c()
  }
  
  # remaining
  if(crnt_idx <= ng) {
    remaining_ids <- snp_assignment[crnt_idx:ng]
    valid_ids <- c(valid_ids, remaining_ids)
  }
  
  # effects
  beta_gx <- runif(ng, a_beta_gx, b_beta_gx) * 
    sample(c(-1, 1), ng, replace = TRUE)
  
 
  beta_gu <- rep(0, ng)
  if(length(corr_pleio_ids) > 0) {
    beta_gu[corr_pleio_ids] <- runif(length(corr_pleio_ids), 
                                     a_beta_gu, 
                                     b_beta_gu) * 
      sample(c(-1, 1), length(corr_pleio_ids), replace = TRUE)
  }
  
  
  alpha_gy <- rep(0, ng)
  if(length(uncorr_pleio_ids) > 0) {
    alpha_gy[uncorr_pleio_ids] <- runif(length(uncorr_pleio_ids), 
                                        a_alpha_gy, 
                                        b_alpha_gy) * 
      sample(c(-1, 1), length(uncorr_pleio_ids), replace = TRUE)
  }
  
  # confounders
  U_genetic_x <- as.vector(beta_gu %*% gx)  
  Ux <- U_genetic_x + rnorm(nx)            
  U_genetic_y <- as.vector(beta_gu %*% gy)  
  Uy <- U_genetic_y + rnorm(ny)         
  
  # exposures
  # X = beta_gx * G + gamma_ux * U + err_x
  Xx <- as.vector(beta_gx %*% gx) +  
    gamma_ux * Ux +               
    rnorm(nx)                     
  
  Xy <- as.vector(beta_gx %*% gy) +  
    gamma_ux * Uy +               
    rnorm(ny)                     
  
  #outcomes---------------
  # Y = alpha_gy * G + theta * X + gamma_uy * U + err_y
  Y <- as.vector(alpha_gy %*% gy) +  
    theta * Xy +                   
    gamma_uy * Uy +                
    rnorm(ny)                 
  
  # Total_gy = α_gy + θ * β_gx + γ_uy * β_gu
  total_effect_gy <- alpha_gy + theta * beta_gx + gamma_uy * beta_gu
  
  # return results
  return(list(
    X = Xx,
    Y = Y,
    gx = gx,
    gy = gy,
    true_beta_gx = beta_gx,     
    true_beta_gu = beta_gu,     
    true_alpha_gy = alpha_gy,   
    true_theta = theta
  ))
}

#2. summary statistics================
generate_summary_stats <- function(data_individual) {
  m <- nrow(data_individual$gx)
  b_exp <- numeric(m)
  se_exp <- numeric(m)
  b_out <- numeric(m)
  se_out <- numeric(m)
  
  betaGXSS = fastSigLm(data_individual$X, t(data_individual$gx))
  betaGYSS = fastSigLm(data_individual$Y, t(data_individual$gy))
  b_exp = betaGXSS$coef
  se_exp = betaGXSS$std
  b_out = betaGYSS$coef
  se_out = betaGYSS$std 
  
  # F stat
  f_individual <- (b_exp^2) / (se_exp^2)
  f_mean <- mean(f_individual, na.rm = TRUE)
  Q <- sum((b_exp / se_exp)^2)
  df <- length(b_exp) - 1
  I2 <- max(0, (Q - df) / Q)
  #f_effective <- f_mean * (1 - I2)
  prop_weak <- mean(f_individual < 10, na.rm = TRUE)
  prop_strong <- mean(f_individual >= 10, na.rm = TRUE)
  
  return(list(
    b_exp = b_exp,
    se_exp = se_exp,
    b_out = b_out,
    se_out = se_out,
    f_mean = f_mean,
    #f_effective = f_effective,
    prop_weak = prop_weak,
    prop_strong = prop_strong,
    I2 = I2
  ))
}

#3. run MR ================
perform_mr_analyses <- function(b_exp, b_out, se_exp, se_out, nx = 1000, ny = 1000) {
  
  results <- list()
  if(any(is.na(c(b_exp, b_out, se_exp, se_out))) || length(b_exp) < 3) {
    return(list(
      ivw_random = list(beta = NA, se = NA, pvalue = NA),
      egger = list(beta = NA, se = NA, pvalue = NA, intercept = NA),
      cml = list(beta = NA, se = NA, pvalue = NA),
      bwmr = list(beta = NA, se = NA, pvalue = NA),
      horse = list(beta = NA, se = NA, pvalue = NA),
      corr2 = list(beta = NA, se = NA, pvalue = NA)
    ))
  }
  
  mr.obj <- MendelianRandomization::mr_input(
    bx = b_exp, bxse = se_exp, 
    by = b_out, byse = se_out
  )
  
  #IVW Random Effects-------------
  IVW_r <- MendelianRandomization::mr_ivw(mr.obj, model = 'random')
  results$ivw_r <- list(
    beta = IVW_r@Estimate,
    se = IVW_r@StdError,
    pvalue = IVW_r@Pvalue
  )
  
  #MR-Egger-----------------------
  Egger <- try(MendelianRandomization::mr_egger(mr.obj), silent = TRUE)
  if(!inherits(Egger, 'try-error') && !is.null(Egger)) {
    results$egger <- list(
      beta = Egger@Estimate,
      se = Egger@StdError.Est,
      pvalue = Egger@Pvalue.Est,
      intercept = Egger@Intercept
    )
  } else {
    results$egger <- list(beta = NA, se = NA, pvalue = NA, intercept = NA)
  }
  
  #cML----------------------------
  cml <- try(MendelianRandomization::mr_cML(
    mr.obj, MA = TRUE, DP = FALSE, num_pert = 100, n = nx
  ), silent = TRUE)
  
  if(!inherits(cml, 'try-error') && !is.null(cml)) {
    results$cml <- list(
      beta = cml@Estimate,
      se = cml@StdError,
      pvalue = cml@Pvalue
    )
  } else {
    results$cml <- list(beta = NA, se = NA, pvalue = NA)
  }
  
  #BWMR-----------------------------
  bwmr_result <- try(BWMR(
    gammahat = b_exp, Gammahat = b_out,
    sigmaX = se_exp, sigmaY = se_out
  ), silent = TRUE)
  
  if(!inherits(bwmr_result, 'try-error')) {
    results$bwmr <- list(
      beta = bwmr_result$beta,
      se = bwmr_result$se_beta,
      pvalue = bwmr_result$P_value
    )
  } else {
    results$bwmr <- list(beta = NA, se = NA, pvalue = NA)
  }
  
  
  #MR-horse--------------------------
  if(exists("mr_horse")) {
    D <- data.frame(
      betaX = b_exp, betaXse = se_exp,
      betaY = b_out, betaYse = se_out
    )
    
    horse_result <- try(mr_horse(D), silent = TRUE)
    if(!inherits(horse_result, 'try-error') && !is.null(horse_result)) {
      b_horse <- horse_result$MR_Estimate$Estimate
      se_horse <- horse_result$MR_Estimate$SD
      z_horse <- b_horse / se_horse
      p_horse <- 2 * pnorm(-abs(z_horse))
      
      results$horse <- list(
        beta = b_horse, se = se_horse, pvalue = p_horse
      )
    } else {
      results$horse <- list(beta = NA, se = NA, pvalue = NA)
    }
  } else {
    results$horse <- list(beta = NA, se = NA, pvalue = NA)
  }
  
  #MR-Corr2----------------------------
  opt_corr <- list(
    agm = 0.001, bgm = 0.001, aal = 0.001, bal = 0.001,
    a = 1, b = length(b_exp), maxIter = 4000, thin = 10, burnin = 1000
  )
  
  corr2_result <- try(MRcorr(
    gammah = b_exp, Gammah = b_out,
    se1 = se_exp, se2 = se_out, opt = opt_corr
  ), silent = TRUE)
  
  if(!inherits(corr2_result, 'try-error') && !is.null(corr2_result)) {
    b_corr2 <- mean(corr2_result$Beta0res)
    se_corr2 <- sd(corr2_result$Beta0res)
    p_corr2 <- 2 * (1 - pnorm(abs(b_corr2/se_corr2)))
    
    results$corr2 <- list(
      beta = b_corr2, se = se_corr2, pvalue = p_corr2
    )
  } else {
    results$corr2 <- list(beta = NA, se = NA, pvalue = NA)
  }
  
  return(results)
}

#4. run simulations=================
run_simulation <- function(
    n_sim = 1,
    ng = 10,
    nx = 1000,
    ny = 1000,
    theta = 0.1,
    prop_valid = 0.5,
    prop_correlated_pleio = 0.25,
    prop_uncorrelated_pleio = 0.25,
    gamma_ux = 1,
    gamma_uy = 1
) {
  
  # mkdir
  for(dir in c("simulation_data2", "simulation_results2")) {
    if(!dir.exists(dir)) dir.create(dir, recursive = TRUE)
  }
  
  results <- list()
  pb <- txtProgressBar(min = 0, max = n_sim, style = 3)
  
  for(sim_id in 1:n_sim) {
    
    # data generation
    data_ind <- data_generation(
      ng = ng, nx = nx, ny = ny,
      theta = theta,
      prop_valid = prop_valid,
      prop_correlated_pleio = prop_correlated_pleio,
      prop_uncorrelated_pleio = prop_uncorrelated_pleio,
      gamma_ux = gamma_ux,
      gamma_uy = gamma_uy
    )
    
    # generate summary statistics
    summ_stats <- generate_summary_stats(data_ind)
    
    # save
    if(sim_id == 1) {
      summary_df <- data.frame(
        snp_id = 1:ng,
        b_exp = summ_stats$b_exp,
        se_exp = summ_stats$se_exp,
        p_exp = 2 * pnorm(-abs(summ_stats$b_exp / summ_stats$se_exp)),
        b_out = summ_stats$b_out,
        se_out = summ_stats$se_out,
        p_out = 2 * pnorm(-abs(summ_stats$b_out / summ_stats$se_out)),
        f_stat = (summ_stats$b_exp / summ_stats$se_exp)^2
      )
      
      write.csv(summary_df,
                file = paste0("simulation_data2/sim_", sim_id, "_summary_stats.csv"),
                row.names = FALSE)
      
      # 真实参数
      params_df <- data.frame(
        snp_id = 1:ng,
        beta_gx = data_ind$true_beta_gx,
        beta_gu = data_ind$true_beta_gu,
        alpha_gy = data_ind$true_alpha_gy,
        theta = theta
      )
      
      write.csv(params_df,
                file = paste0("simulation_data2/sim_", sim_id, "_true_params.csv"),
                row.names = FALSE)
    }
    
    # run mr
    b_exp <- as.numeric(summ_stats$b_exp)
    b_out <- as.numeric(summ_stats$b_out)
    se_exp <- as.numeric(summ_stats$se_exp)
    se_out <- as.numeric(summ_stats$se_out)
    
    mr_results <- perform_mr_analyses(b_exp, b_out, se_exp, se_out, nx, ny)
    
    # save results
    sim_results <- list(
      sim_id = sim_id,
      true_theta = theta,
      prop_valid = prop_valid,
      prop_corr_pleio = prop_correlated_pleio,
      prop_uncorr_pleio = prop_uncorrelated_pleio,
      
      ivw_r_beta = mr_results$ivw_r$beta,
      ivw_r_se = mr_results$ivw_r$se,
      ivw_r_pvalue = mr_results$ivw_r$pvalue,
      
      egger_beta = mr_results$egger$beta,
      egger_se = mr_results$egger$se,
      egger_pvalue = mr_results$egger$pvalue,
      egger_intercept = mr_results$egger$intercept,
      
      cml_beta = mr_results$cml$beta,
      cml_se = mr_results$cml$se,
      cml_pvalue = mr_results$cml$pvalue,
      
      bwmr_beta = mr_results$bwmr$beta,
      bwmr_se = mr_results$bwmr$se,
      bwmr_pvalue = mr_results$bwmr$pvalue,
      
      horse_beta = mr_results$horse$beta,
      horse_se = mr_results$horse$se,
      horse_pvalue = mr_results$horse$pvalue,
      
      corr2_beta = mr_results$corr2$beta,
      corr2_se = mr_results$corr2$se,
      corr2_pvalue = mr_results$corr2$pvalue
    )
    
    results[[sim_id]] <- sim_results
    setTxtProgressBar(pb, sim_id)
  }
  
  close(pb)
  
  # save
  results_df <- do.call(rbind, lapply(results, as.data.frame))
  
  file_name <- sprintf(
    "sim_n%d_ng%d_theta%.2f_valid%.2f_corrPleio%.2f_uncorrPleio%.2f.csv",
    n_sim, ng, theta, prop_valid, prop_correlated_pleio, prop_uncorrelated_pleio
  )
  
  write.csv(results_df, 
            file.path("simulation_results", file_name), 
            row.names = FALSE)
  
  cat("\nDone! results are saved in", file_name, "\n")
  return(results_df)
}

